" AUTOGENERATED BY dump.sh, do not edit
function! vimelixirtrace#dump#dump(fname, code, testSpec)

	let txt = "\n
    \\n
    \test_spec = \"%%TEST_SPEC%%\"\n
    \\n
    \:dbg.stop_clear\n
    \:dbg.start\n
    \\n
    \port_fun = :dbg.trace_port(:file, '%%FILE%%')\n
    \:dbg.tracer(:port, port_fun)\n
    \\n
    \is_running_test = (test_spec != \"\")\n
    \\n
    \if is_running_test do\n
    \  ExUnit.start autorun: false, trace: true, formatters: []\n
    \  single_file = test_spec\n
    \  {single_file, opts} = ExUnit.Filters.parse_path(single_file)\n
    \  ExUnit.configure(opts)\n
    \  Code.require_file(single_file)\n
    \  ExUnit.Server.cases_loaded()\n
    \\n
    \  # manually add tracing of test runner so that\n
    \  # we can find exact call which started test execution\n
    \  # and executed AFTER test execution\n
    \  # so that the run log will be clean from ExUnit internal messages\n
    \  :dbg.tpl ExUnit.Runner, [{:'_', [], [{:return_trace}]}]\n
    \\n
    \end\n
    \\n
    \alias Mix.Tasks.Compile.Elixir, as: E\n
    \import Mix.Compilers.Elixir, only: [read_manifest: 2, module: 1]\n
    \\n
    \# start tracing for all modules in project\n
    \for manifest <- E.manifests(),\n
    \  module(module: mod_name) <- read_manifest(manifest, \"\"),\n
    \  do:\n
    \    :dbg.tpl mod_name, [{:'_', [], [{:return_trace}]}]\n
    \\n
    \:dbg.p(:new_processes, [:c, :m])\n
    \\n
    \\n
    \if is_running_test do\n
    \  spawn(fn() -> ExUnit.run() end)\n
    \else\n
    \  # TODO: add waiting until CODE finishes execution and then only stop\n
    \  # the tracer\n
    \  spawn(fn() -> %%CODE%% end)\n
    \  #%%CODE%%\n
    \end\n
    \\n
    \Process.sleep 1500\n
    \:dbg.trace_port_control(node(), :flush)\n
    \:dbg.stop\n
    \\n
    \defmodule TraceReader do\n
    \  defstruct skip_test_internals: false,\n
    \            procmap: %{},     # map PIDs to letter A..Z\n
    \            proc_level: %{},  # track call/return depth in each processk\n
    \            prev_result: :no_results_defined,  # use to collapse tail resucsion results\n
    \            prev_msg: :no_msg_defined\n
    \\n
    \  #{:trace, #PID<0.275.0>, :call, {MapUtils, :deep_merge, [%{a: 123, b: %{c: 123}}, %{b: %{c: 123123}}]}}\n
    \  def read({:trace, _, :return_from, {ExUnit.Runner, :exec_test, _}, _}, %{skip_test_internals: false}=state) do\n
    \    # return from exec_test triggers skip mode\n
    \    %{state | skip_test_internals: true}\n
    \  end\n
    \\n
    \  def read({:trace, _, :call, {ExUnit.Runner, :exec_test, _}}, %{skip_test_internals: true}=state) do\n
    \    # running exec_test stops skip mode\n
    \    %{state | skip_test_internals: false}\n
    \  end\n
    \\n
    \  # while skip_test_internals is true - skip all trace messages\n
    \  def read({:trace, _, :call, _}, %{skip_test_internals: true}=state) do\n
    \    state\n
    \  end\n
    \  def read({:trace, _, :return_from, _, _}, %{skip_test_internals: true}=state) do\n
    \    state\n
    \  end\n
    \  def read({:trace, _, :send, _, _}, %{skip_test_internals: true}=state) do\n
    \    state\n
    \  end\n
    \  def read({:trace, _, :receive, _}, %{skip_test_internals: true}=state) do\n
    \    state\n
    \  end\n
    \\n
    \  def read({:trace, pid, :send, msg, to_pid}, state) do\n
    \    {proc_name, state} = proc2name(pid, state)\n
    \    {to_proc, state} = proc2name(to_pid, state)\n
    \\n
    \    msg_view = inspect(msg, width: 70, pretty: true)\n
    \\n
    \    if msg_view =~ ~R[\n] do\n
    \      first_line = msg_view |> String.split(\"\n\") |> List.first()\n
    \      IO.puts \"#{proc_name}->#{to_proc}: #{first_line}...\"\n
    \      IO.puts \">msg\n\" <> msg_view <> \"\n<msg\"\n
    \    else\n
    \      IO.puts \"#{proc_name}->#{to_proc}: #{msg_view}\"\n
    \    end\n
    \\n
    \    state = %{state| prev_msg: msg}\n
    \    state = %{state| prev_result: :no_results_defined}\n
    \    state\n
    \  end\n
    \  def read({:trace, pid, :send_to_non_existing_process, msg, to_pid}, state) do\n
    \    {proc_name, state} = proc2name(pid, state)\n
    \    {to_proc, state} = proc2name(to_pid, state)\n
    \\n
    \    msg_view = inspect(msg, width: 70, pretty: true)\n
    \\n
    \    if msg_view =~ ~R[\n] do\n
    \      first_line = msg_view |> String.split(\"\n\") |> List.first()\n
    \      IO.puts \"#{proc_name}->☠#{to_proc}: #{first_line}...\"\n
    \      IO.puts \">msg\n\" <> msg_view <> \"\n<msg\"\n
    \    else\n
    \      IO.puts \"#{proc_name}->☠#{to_proc}: #{msg_view}\"\n
    \    end\n
    \\n
    \    state = %{state| prev_msg: msg}\n
    \    state = %{state| prev_result: :no_results_defined}\n
    \    state\n
    \  end\n
    \  def read({:trace, pid, :receive, msg}, state) do\n
    \    {proc_name, state} = proc2name(pid, state)\n
    \\n
    \    msg_view = if msg == state.prev_msg do\n
    \      \" —″— \"\n
    \    else\n
    \      inspect(msg, width: 70, pretty: true)\n
    \    end\n
    \\n
    \    if msg_view =~ ~R[\n] do\n
    \      first_line = msg_view |> String.split(\"\n\") |> List.first()\n
    \      IO.puts \"->#{proc_name}: #{first_line}...\"\n
    \      IO.puts \">msg\n\" <> msg_view <> \"\n<msg\"\n
    \    else\n
    \      IO.puts \"->#{proc_name}: #{msg_view}\"\n
    \    end\n
    \\n
    \    state = %{state| prev_msg: msg}\n
    \    state = %{state| prev_result: :no_results_defined}\n
    \    state\n
    \  end\n
    \\n
    \  def read({:trace, pid, :call, {m, f, args}}, state) do\n
    \    {proc_name, state} = proc2name(pid, state)\n
    \    {level, state} = proc_change_level(pid, state, +1)\n
    \    state = %{state| prev_result: :no_results_defined}\n
    \    state = %{state| prev_msg: :no_msg_defined}\n
    \\n
    \    args_view = args |> Enum.map(&inspect(&1, width: 70, pretty: true))\n
    \                |> Enum.join(\"❟ \")\n
    \\n
    \    arity = length(args)\n
    \\n
    \    if args_view =~ ~R[\n] do\n
    \      first_line = args_view |> String.split(\"\n\") |> List.first()\n
    \      IO.puts \"#{proc_name}:#{level}: call #{inspect(m)}:#{f}/#{arity} (#{first_line} ...)\"\n
    \      IO.puts \">args\n\" <> args_view <> \"\n<args\"\n
    \    else\n
    \      IO.puts \"#{proc_name}:#{level}: call #{inspect(m)}:#{f}/#{arity} (#{args_view})\"\n
    \    end\n
    \\n
    \    state\n
    \  end\n
    \\n
    \  #{:trace, #PID<0.275.0>, :return_from, {MapUtils, :deep_resolve, 3}, 123123}\n
    \  def read({:trace, pid, :return_from, {m, f, arity}, result}, state) do\n
    \    state = %{state| prev_msg: :no_msg_defined}\n
    \\n
    \    {proc_name, state} = proc2name(pid, state)\n
    \    # nil if no calls to this process yet, should never occur\n
    \    level = state.proc_level[pid]\n
    \\n
    \    {result_view, state} = if result == state.prev_result do\n
    \      {\" —″— \", state}\n
    \    else\n
    \      result_view = inspect(result, width: 70, pretty: true)\n
    \      {result_view, %{state| prev_result: result}}\n
    \    end\n
    \\n
    \    if result_view =~ ~R[\n] do\n
    \      first_line = result_view |> String.split(\"\n\") |> List.first()\n
    \      IO.puts \"#{proc_name}:#{level}: ret  #{inspect(m)}:#{f}/#{arity} -> #{first_line}...\"\n
    \      IO.puts \">results\n\" <> result_view <> \"\n<results\"\n
    \    else\n
    \      IO.puts \"#{proc_name}:#{level}: ret  #{inspect(m)}:#{f}/#{arity} -> #{result_view}\"\n
    \    end\n
    \\n
    \    {_, state} = proc_change_level(pid, state, -1)\n
    \    state\n
    \  end\n
    \\n
    \#{:trace, #PID<0.228.0>, :send, {:code_call, #PID<0.228.0>, {:ensure_loaded, ExUnit.EventManager}}, :code_server}\n
    \#{:trace, #PID<0.228.0>, :receive, {:code_server, {:module, ExUnit.EventManager}}}\n
    \\n
    \  def read(:end_of_trace,state) do\n
    \    IO.puts \"======== trace stop ========\"\n
    \    state\n
    \  end\n
    \  def read(x,state) do\n
    \    IO.inspect x, limit: 10000, pretty: true, width: 140\n
    \    state\n
    \  end\n
    \\n
    \  def proc2name(pid, state) do\n
    \    if Map.has_key?(state.procmap, pid) do\n
    \      {state.procmap[pid], state}\n
    \    else\n
    \      proc_number = \"#{[map_size(state.procmap) + ?A]}\"\n
    \      procmap = Map.put state.procmap, pid, proc_number\n
    \      {proc_number, %{state| procmap: procmap}}\n
    \    end\n
    \  end\n
    \\n
    \  def proc_change_level(pid, state, increment) do\n
    \    state = %{state| proc_level: Map.update(state.proc_level, pid, 0, &(&1 + increment))}\n
    \    {state.proc_level[pid], state}\n
    \  end\n
    \\n
    \  def init(do_skip) do\n
    \    %__MODULE__{skip_test_internals: do_skip}\n
    \  end\n
    \end\n
    \\n
    \IO.puts \"======== trace start ========\"\n
    \:dbg.trace_client(:file, '%%FILE%%', {&TraceReader.read/2, TraceReader.init(is_running_test) })\n
    \Process.sleep 1500\n
\"

	let tempName = fnameescape(a:fname)

	let txt = substitute(txt, '%%CODE%%', a:code, 'g')
	let txt = substitute(txt, '%%FILE%%', tempName, 'g')
	let txt = substitute(txt, '%%TEST_SPEC%%', a:testSpec, 'g')

	return txt
endfunction
