" AUTOGENERATED BY dump.sh, do not edit
function! vimelixirtrace#dump#dump(fname, code) 

	let txt = "\n
    \\n
    \IO.puts \"======== trace start ========\"\n
    \\n
    \:dbg.stop_clear\n
    \:dbg.start\n
    \\n
    \port_fun = :dbg.trace_port(:file, '%%FILE%%')\n
    \:dbg.tracer(:port, port_fun)\n
    \\n
    \alias Mix.Tasks.Compile.Elixir, as: E\n
    \import Mix.Compilers.Elixir, only: [read_manifest: 2, module: 1]\n
    \\n
    \# start tracing for all modules in project\n
    \for manifest <- E.manifests(),\n
    \  module(module: mod_name) <- read_manifest(manifest, \"\"), \n
    \  do: \n
    \    :dbg.tpl mod_name, [{:'_', [], [{:return_trace}]}]\n
    \\n
    \:dbg.p(:new_processes, [:c, :m])\n
    \\n
    \# TODO: add waiting until CODE finishes execution and then only stop \n
    \# the tracer \n
    \spawn(fn() -> %%CODE%% end)\n
    \\n
    \:dbg.trace_port_control(node(), :flush)\n
    \:dbg.stop\n
    \Process.sleep 1500\n
    \\n
    \defmodule TraceReader do\n
    \  defstruct procmap: %{},     # map PIDs to letter A..Z\n
    \            proc_level: %{},  # track call/return depth in each processk\n
    \            prev_result: :no_results_defined  # use to collapse tail resucsion results\n
    \\n
    \  #{:trace, #PID<0.275.0>, :call, {MapUtils, :deep_merge, [%{a: 123, b: %{c: 123}}, %{b: %{c: 123123}}]}}\n
    \  def read({:trace, pid, :call, {m, f, args}}, state) do\n
    \    {proc_name, state} = proc2name(pid, state)\n
    \    {level, state} = proc_change_level(pid, state, +1)\n
    \    state = %{state| prev_result: :no_results_defined}\n
    \\n
    \    args_view = args |> Enum.map(&inspect(&1, width: 70, pretty: true)) \n
    \                |> Enum.join(\"❟ \")\n
    \\n
    \    arity = length(args)\n
    \\n
    \    if args_view =~ ~R[\n] do\n
    \      first_line = args_view |> String.split(\"\n\") |> List.first()\n
    \      IO.puts \"#{proc_name}:#{level}: call #{inspect(m)}:#{f}/#{arity} (#{first_line} ...)\"\n
    \      IO.puts \">args\n\" <> args_view <> \"\n<args\"\n
    \    else\n
    \      IO.puts \"#{proc_name}:#{level}: call #{inspect(m)}:#{f}/#{arity} (#{args_view})\"\n
    \    end\n
    \\n
    \    state\n
    \  end\n
    \\n
    \  #{:trace, #PID<0.275.0>, :return_from, {MapUtils, :deep_resolve, 3}, 123123}\n
    \  def read({:trace, pid, :return_from, {m, f, arity}, result}, state) do\n
    \    {proc_name, state} = proc2name(pid, state)\n
    \    # nil if no calls to this process yet, should never occur\n
    \    level = state.proc_level[pid]\n
    \\n
    \    {result_view, state} = if result == state.prev_result do\n
    \      {\" —″— \", state}\n
    \    else\n
    \      result_view = inspect(result, width: 70, pretty: true)\n
    \      {result_view, %{state| prev_result: result}}\n
    \    end\n
    \\n
    \    if result_view =~ ~R[\n] do\n
    \      first_line = result_view |> String.split(\"\n\") |> List.first()\n
    \      IO.puts \"#{proc_name}:#{level}: ret  #{inspect(m)}:#{f}/#{arity} -> #{first_line}...\"\n
    \      IO.puts \">results\n\" <> result_view <> \"\n<results\"\n
    \    else\n
    \      IO.puts \"#{proc_name}:#{level}: ret  #{inspect(m)}:#{f}/#{arity} -> #{result_view}\"\n
    \    end\n
    \\n
    \    {_, state} = proc_change_level(pid, state, -1)\n
    \    state\n
    \  end\n
    \  def read(:end_of_trace,state) do\n
    \    state\n
    \  end\n
    \  def read(x,state) do\n
    \    IO.inspect x, limit: 10000, pretty: true, width: 140\n
    \    state \n
    \  end\n
    \\n
    \  def proc2name(pid, state) do\n
    \    if Map.has_key?(state.procmap, pid) do\n
    \      {state.procmap[pid], state}\n
    \    else\n
    \      proc_number = \"#{[map_size(state.procmap) + ?A]}\"\n
    \      procmap = Map.put state.procmap, pid, proc_number\n
    \      {proc_number, %{state| procmap: procmap}}\n
    \    end\n
    \  end\n
    \\n
    \  def proc_change_level(pid, state, increment) do\n
    \    state = %{state| proc_level: Map.update(state.proc_level, pid, 0, &(&1 + increment))}\n
    \    {state.proc_level[pid], state}\n
    \  end\n
    \\n
    \  def init() do\n
    \    %__MODULE__{}\n
    \  end\n
    \end\n
    \\n
    \:dbg.trace_client(:file, '%%FILE%%', {&TraceReader.read/2, TraceReader.init() }) \n
    \Process.sleep 1500\n
    \\n
    \IO.puts \"======== trace stop ========\"\n
\"

	let tempName = fnameescape(a:fname)

	let txt = substitute(txt, '%%CODE%%', a:code, 'g')
	let txt = substitute(txt, '%%FILE%%', tempName, 'g')

	return txt
endfunction
