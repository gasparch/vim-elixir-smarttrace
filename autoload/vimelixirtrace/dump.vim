" AUTOGENERATED BY make.sh, do not edit
function! vimelixirtrace#dump#dump(fname, code, testSpec, helperFile)

	let txt = "\n
    \\n
    \test_spec = \"%%TEST_SPEC%%\"\n
    \is_running_test = (test_spec != \"\")\n
    \trace_gen_timeout = 20_000\n
    \\n
    \defmodule TraceRunner do\n
    \  # 20 sec should be enough for most tests to finish\n
    \  @run_timeout 20_000\n
    \\n
    \  def run(is_running_test, test_spec) do\n
    \    :dbg.stop_clear\n
    \    :dbg.start\n
    \\n
    \    port_fun = :dbg.trace_port(:file, '%%FILE%%')\n
    \    :dbg.tracer(:port, port_fun)\n
    \\n
    \    if is_running_test do\n
    \      Code.require_file(\"%%TEST_HELPER%%\")\n
    \      ExUnit.start autorun: false, trace: true, formatters: []\n
    \      single_file = test_spec\n
    \      {single_file, opts} = ExUnit.Filters.parse_path(single_file)\n
    \      ExUnit.configure(opts)\n
    \      Code.require_file(single_file)\n
    \      ExUnit.Server.cases_loaded()\n
    \\n
    \      # manually add tracing of test runner so that\n
    \      # we can find exact call which started test execution\n
    \      # and executed AFTER test execution\n
    \        # so that the run log will be clean from ExUnit internal messages\n
    \        :dbg.tpl ExUnit.Runner, [{:'_', [], [{:return_trace}]}]\n
    \    end\n
    \\n
    \    alias Mix.Tasks.Compile.Elixir, as: E\n
    \    import Mix.Compilers.Elixir, only: [read_manifest: 2, module: 1]\n
    \\n
    \    # start tracing for all modules in project\n
    \    for manifest <- E.manifests(),\n
    \    module(module: mod_name) <- read_manifest(manifest, \"\"),\n
    \    do:\n
    \    :dbg.tpl mod_name, [{:'_', [], [{:return_trace}]}]\n
    \\n
    \    :dbg.p(:new_processes, [:c, :m])\n
    \\n
    \    if is_running_test do\n
    \      runner(fn() -> ExUnit.run() end)\n
    \    else\n
    \      # TODO: add waiting until CODE finishes execution and then only stop\n
    \      # the tracer\n
    \      runner(fn() ->\n
    \        %%CODE%%\n
    \      end)\n
    \    end\n
    \\n
    \    :dbg.trace_port_control(node(), :flush)\n
    \    :dbg.stop\n
    \  end\n
    \\n
    \  def runner(fun) do\n
    \    Process.flag(:trap_exit, true)\n
    \\n
    \    pid = spawn_link(fun)\n
    \\n
    \    receive do\n
    \      {:EXIT, _, _} -> :ok\n
    \    after\n
    \      @run_timeout ->\n
    \        Process.exit(pid, :kill)\n
    \        :not_ok\n
    \    end\n
    \  end\n
    \end\n
    \\n
    \\n
    \\n
    \\n
    \defmodule TraceReader do\n
    \  defstruct skip_test_internals: false,\n
    \            procmap: %{},     # map PIDs to letter A..Z\n
    \            proc_level: %{},  # track call/return depth in each processk\n
    \            prev_result: :no_results_defined,  # use to collapse tail resucsion results\n
    \            prev_msg: :no_msg_defined,\n
    \            prev_receiver: :no_msg_defined,\n
    \            seen_modules: %{},\n
    \            notify_pid: nil\n
    \\n
    \  #{:trace, #PID<0.275.0>, :call, {MapUtils, :deep_merge, [%{a: 123, b: %{c: 123}}, %{b: %{c: 123123}}]}}\n
    \  def read({:trace, _, :return_from, {ExUnit.Runner, :exec_test, _}, _}, %{skip_test_internals: false}=state) do\n
    \    # return from exec_test triggers skip mode\n
    \    %{state | skip_test_internals: true}\n
    \  end\n
    \\n
    \  def read({:trace, _, :call, {ExUnit.Runner, :exec_test, _}}, %{skip_test_internals: true}=state) do\n
    \    # running exec_test stops skip mode\n
    \    %{state | skip_test_internals: false}\n
    \  end\n
    \\n
    \  # while skip_test_internals is true - skip all trace messages\n
    \  def read({:trace, _, :call, _}, %{skip_test_internals: true}=state) do\n
    \    state\n
    \  end\n
    \  def read({:trace, _, :return_from, _, _}, %{skip_test_internals: true}=state) do\n
    \    state\n
    \  end\n
    \  def read({:trace, _, :send, _, _}, %{skip_test_internals: true}=state) do\n
    \    state\n
    \  end\n
    \  def read({:trace, _, :receive, _}, %{skip_test_internals: true}=state) do\n
    \    state\n
    \  end\n
    \\n
    \  # part when test started and we show messages from test processes\n
    \  # GenServer processing\n
    \  def read({:trace, pid, :send, {:\"$gen_call\", _, msg} = full_msg, to_pid}, state) do\n
    \    {proc_name, state} = proc2name(pid, state)\n
    \    {to_proc, state} = proc2name(to_pid, state)\n
    \\n
    \    msg_view = my_inspect(state, msg, width: 70, pretty: true)\n
    \\n
    \    prefix = \"#{proc_name}→#{to_proc}: GenServer.call (\\\"ꜝ#{to_proc}\\\"❟\"\n
    \    print_call(prefix, msg_view, \"\", \")\")\n
    \\n
    \    state = %{state| prev_msg: full_msg, prev_receiver: to_pid}\n
    \    state = %{state| prev_result: :no_results_defined}\n
    \    state\n
    \  end\n
    \  def read({:trace, pid, :call, {m, f, args}}, state) when f == :handle_call do\n
    \    state = add_seen_module(m, state)\n
    \    {proc_name, state} = proc2name(pid, state)\n
    \    {level, state} = proc_change_level(pid, state, +1)\n
    \    state = %{state| prev_result: :no_results_defined}\n
    \    state = %{state| prev_msg: :no_msg_defined}\n
    \\n
    \    args_view = args |> Enum.map(&my_inspect(state, &1, width: 70, pretty: true))\n
    \                |> Enum.join(\"❟,❟ \")\n
    \\n
    \    arity = length(args)\n
    \\n
    \    prefix = \"#{proc_name}:#{level}: #{f} #{my_inspect(state, m)}\"\n
    \    print_call(prefix, args_view, \"(\", \")\")\n
    \\n
    \    state\n
    \  end\n
    \  def read({:trace, pid, :return_from, {m, f, arity}, result}, state) when\n
    \    f == :handle_call do\n
    \    state = %{state| prev_msg: {:ignore_reference, elem(result, 1)}}\n
    \\n
    \    {proc_name, state} = proc2name(pid, state)\n
    \    # nil if no calls to this process yet, should never occur\n
    \    level = state.proc_level[pid]\n
    \\n
    \    {result_view, state} = if result == state.prev_result do\n
    \      {\" —″— \", state}\n
    \    else\n
    \      result_view = my_inspect(state, result, width: 70, pretty: true)\n
    \      {result_view, %{state| prev_result: result}}\n
    \    end\n
    \\n
    \    prefix = \"#{proc_name}:#{level}: ⤶#{f} #{my_inspect(state, m)}\"\n
    \    print_call(prefix, result_view)\n
    \\n
    \    {_, state} = proc_change_level(pid, state, -1)\n
    \    state\n
    \  end\n
    \  def read({:trace, _, :send, {ref, res}, _},\n
    \          %{prev_msg: {:ignore_reference, res1}} = state) when is_reference(ref) and res == res1 do\n
    \    state\n
    \  end\n
    \  def read({:trace, _, :receive, {ref, res}},\n
    \          %{prev_msg: {:ignore_reference, res1}} = state) when is_reference(ref) and res == res1 do\n
    \    state = %{state| prev_msg: :no_msg_defined}\n
    \    state\n
    \  end\n
    \\n
    \\n
    \  # generic messages/calls\n
    \  def read({:trace, pid, :send, msg, to_pid}, state) do\n
    \    {proc_name, state} = proc2name(pid, state)\n
    \    {to_proc, state} = proc2name(to_pid, state)\n
    \\n
    \    msg_view = my_inspect(state, msg, width: 70, pretty: true)\n
    \\n
    \    prefix = \"#{proc_name}→#{to_proc}:\"\n
    \    print_call(prefix, msg_view)\n
    \\n
    \    state = %{state| prev_msg: msg, prev_receiver: to_pid}\n
    \    state = %{state| prev_result: :no_results_defined}\n
    \    state\n
    \  end\n
    \  def read({:trace, pid, :send_to_non_existing_process, msg, to_pid}, state) do\n
    \    {proc_name, state} = proc2name(pid, state)\n
    \    {to_proc, state} = proc2name(to_pid, state)\n
    \\n
    \    msg_view = my_inspect(state, msg, width: 70, pretty: true)\n
    \\n
    \    prefix = \"#{proc_name}→☠#{to_proc}:\"\n
    \    print_call(prefix, msg_view)\n
    \\n
    \    state = %{state| prev_msg: :no_msg_defined}\n
    \    state = %{state| prev_result: :no_results_defined}\n
    \    state\n
    \  end\n
    \  def read({:trace, pid, :receive, msg}, %{prev_receiver: pid, prev_msg: msg}=state) do\n
    \    # do not show receive of message, which we just showed we sent\n
    \    state\n
    \  end\n
    \  def read({:trace, pid, :receive, msg}, state) do\n
    \    {proc_name, state} = proc2name(pid, state)\n
    \\n
    \    msg_view = if msg == state.prev_msg do\n
    \      \" —″— \"\n
    \    else\n
    \      my_inspect(state, msg, width: 70, pretty: true)\n
    \    end\n
    \\n
    \    prefix = \"#{proc_name}←:\"\n
    \    print_call(prefix, msg_view)\n
    \\n
    \    state = %{state| prev_msg: msg}\n
    \    state = %{state| prev_result: :no_results_defined}\n
    \    state\n
    \  end\n
    \\n
    \  def read({:trace, pid, :call, {m, f, args}}, state) do\n
    \    state = add_seen_module(m, state)\n
    \    {proc_name, state} = proc2name(pid, state)\n
    \    {level, state} = proc_change_level(pid, state, +1)\n
    \    state = %{state| prev_result: :no_results_defined}\n
    \    state = %{state| prev_msg: :no_msg_defined}\n
    \\n
    \    args_view = args |> Enum.map(&my_inspect(state, &1, width: 70, pretty: true))\n
    \                |> Enum.join(\"❟,❟ \")\n
    \\n
    \    arity = length(args)\n
    \\n
    \    prefix = \"#{proc_name}:#{level}: call #{my_inspect(state, m)}:#{f}/#{arity}\"\n
    \    print_call(prefix, args_view, \"(\", \")\")\n
    \\n
    \    state\n
    \  end\n
    \\n
    \  #{:trace, #PID<0.275.0>, :return_from, {MapUtils, :deep_resolve, 3}, 123123}\n
    \  def read({:trace, pid, :return_from, {m, f, arity}, result}, state) do\n
    \    state = %{state| prev_msg: :no_msg_defined}\n
    \\n
    \    {proc_name, state} = proc2name(pid, state)\n
    \    # nil if no calls to this process yet, should never occur\n
    \    level = state.proc_level[pid]\n
    \\n
    \    {result_view, state} = if result == state.prev_result do\n
    \      {\" —″— \", state}\n
    \    else\n
    \      result_view = my_inspect(state, result, width: 70, pretty: true)\n
    \      {result_view, %{state| prev_result: result}}\n
    \    end\n
    \\n
    \    prefix = \"#{proc_name}:#{level}: ret  #{my_inspect(state, m)}:#{f}/#{arity} ⤶\"\n
    \    print_call(prefix, result_view)\n
    \\n
    \    {_, state} = proc_change_level(pid, state, -1)\n
    \    state\n
    \  end\n
    \\n
    \#{:trace, #PID<0.228.0>, :send, {:code_call, #PID<0.228.0>, {:ensure_loaded, ExUnit.EventManager}}, :code_server}\n
    \#{:trace, #PID<0.228.0>, :receive, {:code_server, {:module, ExUnit.EventManager}}}\n
    \\n
    \  def read(:end_of_trace, state) do\n
    \    module_paths = :code.all_loaded |> Enum.into(%{}) |> Map.take(Map.keys(state.seen_modules))\n
    \\n
    \    IO.puts \"======== trace stop ========\"\n
    \    Enum.each(module_paths, fn({mod,filename}) ->\n
    \      lines = LineDecoder.get_translated_lines(filename)\n
    \      src_filename = mod.module_info(:compile)[:source]\n
    \\n
    \      Enum.each(lines, fn({{fun_name, fun_arity}, line}) ->\n
    \        if line > -1 do\n
    \          IO.puts \"#{mod}:#{fun_name}:#{fun_arity}:#{line}:#{src_filename}\"\n
    \        end\n
    \      end)\n
    \    end)\n
    \    IO.puts \"======== module lines ========\"\n
    \\n
    \\n
    \    send state.notify_pid, :ok\n
    \    state\n
    \  end\n
    \  def read(x,state) do\n
    \    IO.inspect x, limit: 10000, pretty: true, width: 140\n
    \    state\n
    \  end\n
    \\n
    \  defp print_call(prefix, args_view, open_brace\\\\\"\", close_brace\\\\\"\") do\n
    \    if args_view =~ ~R[\\n] do\n
    \      split_lines = \"#{open_brace}#{args_view}\" |> String.split(\"\\n\")\n
    \      first_line = List.first(split_lines)\n
    \      split_lines = split_lines |> Enum.map(&\"    #{&1}\") |> Enum.join(\"\\n\")\n
    \      IO.puts \"#{prefix} #{first_line}… «⋯\"\n
    \      IO.puts \"#{split_lines}#{close_brace} ⋯»\"\n
    \    else\n
    \      IO.puts \"#{prefix} #{open_brace}#{args_view}#{close_brace}\"\n
    \    end\n
    \  end\n
    \\n
    \  def proc2name(pid, state) do\n
    \    if Map.has_key?(state.procmap, pid) do\n
    \      {state.procmap[pid], state}\n
    \    else\n
    \      proc_number = \"#{[map_size(state.procmap) + ?A]}\"\n
    \      procmap = Map.put state.procmap, pid, proc_number\n
    \      {proc_number, %{state| procmap: procmap}}\n
    \    end\n
    \  end\n
    \\n
    \  def proc_change_level(pid, state, increment) do\n
    \    state = %{state| proc_level: Map.update(state.proc_level, pid, 0, &(&1 + increment))}\n
    \    {state.proc_level[pid], state}\n
    \  end\n
    \\n
    \  defp add_seen_module(mod, state) do\n
    \    %{state| seen_modules: Map.put(state.seen_modules, mod, 1)}\n
    \  end\n
    \\n
    \  defp my_inspect(state, msg, options\\\\[]) do\n
    \    inspect(replace_pids(msg, state), options)\n
    \  end\n
    \\n
    \  defp replace_pids({k,v}=val, state) when is_pid(v) do\n
    \    case state.procmap do\n
    \      %{^v => name} -> {k, \"ꜝ#{name}\"}\n
    \      _ -> val\n
    \    end\n
    \  end\n
    \  defp replace_pids(v, state) when is_pid(v) do\n
    \    case state.procmap do\n
    \      %{^v => name} -> \"ꜝ#{name}\"\n
    \      _ -> v\n
    \    end\n
    \  end\n
    \  defp replace_pids(%{__struct__: type} = msg, state) do\n
    \    msg\n
    \    |> Map.delete(:__struct__)\n
    \    |> Enum.map(&replace_pids(&1, state))\n
    \    |> Enum.into(%{})\n
    \    |> Map.put(:__struct__, type)\n
    \  end\n
    \  defp replace_pids(msg, state) when is_map(msg) do\n
    \    msg |> Enum.map(&replace_pids(&1, state)) |> Enum.into(%{})\n
    \  end\n
    \  defp replace_pids(msg, state) when is_list(msg) do\n
    \    msg |> Enum.map(&replace_pids(&1, state))\n
    \  end\n
    \  defp replace_pids(msg, state) when is_tuple(msg) do\n
    \    msg |> Tuple.to_list |> Enum.map(&replace_pids(&1, state)) |> List.to_tuple\n
    \  end\n
    \  defp replace_pids(val, _) do\n
    \    val\n
    \  end\n
    \\n
    \  def init(do_skip, notify_pid) do\n
    \    %__MODULE__{skip_test_internals: do_skip, notify_pid: notify_pid}\n
    \  end\n
    \end\n
    \\n
    \defmodule LineDecoder do\n
    \  use Bitwise\n
    \\n
    \  @tag_i 1\n
    \  @tag_a 2\n
    \\n
    \  # main entry point to module\n
    \  def get_translated_lines(filename) do\n
    \    lines_hash = get_lines_to_real_lines(filename) |> Enum.into(%{})\n
    \\n
    \    fun_starts = get_disassembly(filename)\n
    \\n
    \    fun_starts |> Enum.map(fn({fun, ln}) -> {fun, lines_hash[ln]} end)\n
    \  end\n
    \\n
    \  def get_lines_to_real_lines(filename) do\n
    \    z = :beam_lib.chunks(filename, ['Line'])\n
    \    {_, {_, [{_, bin}]}} = z\n
    \\n
    \    <<_ver::integer-size(32),_bits::integer-size(32),_numLineInstrs::integer-size(32),numLines::integer-size(32),_numFnames::integer-size(32), tail::binary>> = bin\n
    \\n
    \    #IO.inspect {ver, bits, numLineInstrs, numLines, numFnames}\n
    \\n
    \    tail = :erlang.binary_to_list(tail)\n
    \\n
    \    lst = decode_lines_chunk(tail, numLines+1)\n
    \    lst = Enum.map(lst, fn\n
    \                     ({:a, _}) -> -1\n
    \                     ({:i, n}) -> n\n
    \    end)\n
    \\n
    \    range = 0..(length(lst))\n
    \    Enum.zip(range, lst)\n
    \  end\n
    \\n
    \  def get_disassembly(filename) do\n
    \    {:beam_file, _, _, _, _, funs} = :beam_disasm.file(filename)\n
    \\n
    \    funs = Enum.map(funs, &get_line_reference/1)\n
    \\n
    \    funs\n
    \  end\n
    \\n
    \  defp get_line_reference({:function, fname, arity, _, ops}) do\n
    \    ops = (for {:line, _} = x <- ops, do: elem(x, 1)) |> List.first\n
    \    {{fname, arity}, ops}\n
    \  end\n
    \\n
    \  defp decode_lines_chunk(tail, num) do\n
    \    decode_lines_chunk(tail, num, [])\n
    \  end\n
    \\n
    \  defp decode_lines_chunk(_, 0, acc) do\n
    \    Enum.reverse(acc)\n
    \  end\n
    \\n
    \  # modelled after OTP/lib/compiler/src/beam_disasm.erl\n
    \  defp decode_lines_chunk([b|bs0], num, acc) do\n
    \    tag = decode_tag(b &&& 0b111)\n
    \\n
    \    {{type, val}, tail} = case tag do\n
    \      :a ->\n
    \      case decode_int(tag, b, bs0) do\n
    \        {{:a, 0}, tail} -> {nil, tail}\n
    \        {{:a, _}, tail} -> {{:a, :ignored_atom}, tail}\n
    \      end\n
    \      :i ->\n
    \        decode_int(tag, b, bs0)\n
    \    end\n
    \    decode_lines_chunk(tail, num-1, [{type, val} | acc])\n
    \  end\n
    \\n
    \  defp decode_tag(@tag_i), do: :i\n
    \  defp decode_tag(@tag_a), do: :a\n
    \  defp decode_tag(v), do: raise \"Do not support tag #{v}\"\n
    \\n
    \  defp decode_int(tag,b,bs) when (b &&& 0x08) === 0 do\n
    \    # -----------------------------------------------------------------------\n
    \    #  Decodes an integer value.  Handles positives, negatives, and bignums.\n
    \    #\n
    \    #  Tries to do the opposite of:\n
    \    #    beam_asm:encode(1, 5) =            [81]\n
    \    #    beam_asm:encode(1, 1000) =         [105,232]\n
    \    #    beam_asm:encode(1, 2047) =         [233,255]\n
    \    #    beam_asm:encode(1, 2048) =         [25,8,0]\n
    \    #    beam_asm:encode(1,-1) =            [25,255,255]\n
    \    #    beam_asm:encode(1,-4294967295) =   [121,255,0,0,0,1]\n
    \    #    beam_asm:encode(1, 4294967295) =   [121,0,255,255,255,255]\n
    \    #    beam_asm:encode(1, 429496729501) = [121,99,255,255,255,157]\n
    \    # -----------------------------------------------------------------------\n
    \    #%% N < 16 = 4 bits, NNNN:0:TTT\n
    \    n = b >>> 4\n
    \    {{tag,n},bs}\n
    \  end\n
    \  defp decode_int(tag,b,bs) when (b &&& 0x10) === 0 do\n
    \    #%% N < 2048 = 11 bits = 3:8 bits, NNN:01:TTT, NNNNNNNN\n
    \    [b1|bs1] = bs\n
    \    val0 = b &&& 0b11100000\n
    \    n = (val0 <<< 3) ||| b1\n
    \    {{tag,n},bs1}\n
    \  end\n
    \  defp decode_int(tag,b,bs) do\n
    \    {len,bs1} = decode_int_length(b,bs)\n
    \    {intBs,remBs} = take_bytes(len,bs1)\n
    \    n = build_arg(intBs)\n
    \    [f|_] = intBs\n
    \    num = if f > 127 && tag == :i do\n
    \      decode_negative(n, len)\n
    \    else\n
    \      n\n
    \    end\n
    \    {{tag,num},remBs}\n
    \  end\n
    \\n
    \  # cut very bignum support from here\n
    \  defp decode_int_length(b, bs) do\n
    \    #%% The following imitates get_erlang_integer() in beam_load.c\n
    \    #%% Len is the size of the integer value in bytes\n
    \    case b >>> 5 do\n
    \      7 ->\n
    \        raise \"decode_int, too_big bignum_sublength\"\n
    \      l ->\n
    \        {l+2,bs}\n
    \    end\n
    \  end\n
    \\n
    \  defp take_bytes(n, bs) do\n
    \    take_bytes(n, bs, [])\n
    \  end\n
    \\n
    \  defp take_bytes(n, [b|bs], acc) when n > 0 do\n
    \    take_bytes(n-1, bs, [b|acc])\n
    \  end\n
    \  defp take_bytes(0, bs, acc) do\n
    \    {:lists.reverse(acc), bs}\n
    \  end\n
    \\n
    \  defp build_arg(bs) do\n
    \    build_arg(bs, 0)\n
    \  end\n
    \  defp build_arg([b|bs], n) do\n
    \    build_arg(bs, (n <<< 8) ||| b);\n
    \  end\n
    \  defp build_arg([], n) do\n
    \    n\n
    \  end\n
    \\n
    \  defp decode_negative(n, len) do\n
    \    n - (1 <<< (len*8)) # 8 is number of bits in a byte\n
    \  end\n
    \end\n
    \\n
    \TraceRunner.run(is_running_test, test_spec)\n
    \\n
    \IO.puts \"======== trace start ========\"\n
    \my_pid = self()\n
    \:dbg.trace_client(:file, '%%FILE%%', {&TraceReader.read/2, TraceReader.init(is_running_test, my_pid) })\n
    \\n
    \receive do\n
    \  :ok -> :ok\n
    \after\n
    \  trace_gen_timeout ->\n
    \    IO.puts \"======== trace stop ========\"\n
    \    IO.puts \"======== module lines ========\"\n
    \end\n
\"

	let tempName = fnameescape(a:fname)

	let txt = substitute(txt, '%%CODE%%', a:code, 'g')
	let txt = substitute(txt, '%%FILE%%', tempName, 'g')
	let txt = substitute(txt, '%%TEST_SPEC%%', a:testSpec, 'g')
	let txt = substitute(txt, '%%TEST_HELPER%%', a:helperFile, 'g')

	return txt
endfunction
